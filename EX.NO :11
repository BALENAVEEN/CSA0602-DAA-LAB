#include <stdio.h>

#define MOD 1000000007  // optional if numbers get large

int findPaths(int m, int n, int N, int i, int j) {
    int dp[51][51] = {0};   // current DP state
    int temp[51][51] = {0}; // next DP state
    int result = 0;

    dp[i][j] = 1;  // start position

    for (int step = 1; step <= N; step++) {
        for (int x = 0; x < m; x++) {
            for (int y = 0; y < n; y++) {
                if (dp[x][y] > 0) {
                    // Try moving in 4 directions
                    int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
                    for (int d = 0; d < 4; d++) {
                        int nx = x + dirs[d][0];
                        int ny = y + dirs[d][1];

                        if (nx < 0 || ny < 0 || nx >= m || ny >= n)
                            result = (result + dp[x][y]) % MOD; // moved out
                        else
                            temp[nx][ny] = (temp[nx][ny] + dp[x][y]) % MOD;
                    }
                }
            }
        }

        // copy temp to dp and reset temp
        for (int x = 0; x < m; x++) {
            for (int y = 0; y < n; y++) {
                dp[x][y] = temp[x][y];
                temp[x][y] = 0;
            }
        }
    }

    return result;
}

int main() {
    // Test Case 1
    int m1 = 2, n1 = 2, N1 = 2, i1 = 0, j1 = 0;
    printf("Input: m=%d, n=%d, N=%d, i=%d, j=%d\n", m1, n1, N1, i1, j1);
    printf("Output: %d\n\n", findPaths(m1, n1, N1, i1, j1));

    // Test Case 2
    int m2 = 1, n2 = 3, N2 = 3, i2 = 0, j2 = 1;
    printf("Input: m=%d, n=%d, N=%d, i=%d, j=%d\n", m2, n2, N2, i2, j2);
    printf("Output: %d\n", findPaths(m2, n2, N2, i2, j2));

    return 0;
}
